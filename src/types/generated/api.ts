/* tslint:disable */
/* eslint-disable */
/**
 * Fundamental Stocks API
 * Add, remove, add notes to watched stocks
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddStockRequest
 */
export interface AddStockRequest {
    /**
     * 
     * @type {string}
     * @memberof AddStockRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddStockRequest
     */
    'symbol'?: string;
}
/**
 * 
 * @export
 * @interface GetIncomeStatement200Response
 */
export interface GetIncomeStatement200Response {
    /**
     * 
     * @type {StockMetadata}
     * @memberof GetIncomeStatement200Response
     */
    'meta'?: StockMetadata;
    /**
     * 
     * @type {Array<IncomeStatement>}
     * @memberof GetIncomeStatement200Response
     */
    'income_statement'?: Array<IncomeStatement>;
}
/**
 * 
 * @export
 * @interface GetTimeSeriesData200Response
 */
export interface GetTimeSeriesData200Response {
    /**
     * 
     * @type {GetTimeSeriesData200ResponseMeta}
     * @memberof GetTimeSeriesData200Response
     */
    'meta'?: GetTimeSeriesData200ResponseMeta;
    /**
     * 
     * @type {Array<TimeSeriesPoint>}
     * @memberof GetTimeSeriesData200Response
     */
    'values'?: Array<TimeSeriesPoint>;
    /**
     * 
     * @type {string}
     * @memberof GetTimeSeriesData200Response
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetTimeSeriesData200ResponseMeta
 */
export interface GetTimeSeriesData200ResponseMeta {
    /**
     * 
     * @type {string}
     * @memberof GetTimeSeriesData200ResponseMeta
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTimeSeriesData200ResponseMeta
     */
    'interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTimeSeriesData200ResponseMeta
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTimeSeriesData200ResponseMeta
     */
    'exchange_timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTimeSeriesData200ResponseMeta
     */
    'exchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTimeSeriesData200ResponseMeta
     */
    'mic_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTimeSeriesData200ResponseMeta
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface IncomeStatement
 */
export interface IncomeStatement {
    /**
     * 
     * @type {string}
     * @memberof IncomeStatement
     */
    'fiscal_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'quarter'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'year'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'sales'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'cost_of_goods'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'gross_profit'?: number;
    /**
     * 
     * @type {IncomeStatementOperatingExpense}
     * @memberof IncomeStatement
     */
    'operating_expense'?: IncomeStatementOperatingExpense;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'operating_income'?: number;
    /**
     * 
     * @type {IncomeStatementNonOperatingInterest}
     * @memberof IncomeStatement
     */
    'non_operating_interest'?: IncomeStatementNonOperatingInterest;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'other_income_expense'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'pretax_income'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'income_tax'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'net_income'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'eps_basic'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'eps_diluted'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'basic_shares_outstanding'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'diluted_shares_outstanding'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'ebitda'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'net_income_continuous_operations'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'minority_interests'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatement
     */
    'preferred_stock_dividends'?: number | null;
}
/**
 * 
 * @export
 * @interface IncomeStatementNonOperatingInterest
 */
export interface IncomeStatementNonOperatingInterest {
    /**
     * 
     * @type {number}
     * @memberof IncomeStatementNonOperatingInterest
     */
    'income'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatementNonOperatingInterest
     */
    'expense'?: number;
}
/**
 * 
 * @export
 * @interface IncomeStatementOperatingExpense
 */
export interface IncomeStatementOperatingExpense {
    /**
     * 
     * @type {number}
     * @memberof IncomeStatementOperatingExpense
     */
    'research_and_development'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatementOperatingExpense
     */
    'selling_general_and_administrative'?: number;
    /**
     * 
     * @type {number}
     * @memberof IncomeStatementOperatingExpense
     */
    'other_operating_expenses'?: number | null;
}
/**
 * 
 * @export
 * @interface Note
 */
export interface Note {
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Note
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'notes': string;
    /**
     * 
     * @type {number}
     * @memberof Note
     */
    'priceTarget'?: number;
    /**
     * 
     * @type {string}
     * @memberof Note
     */
    'followUpDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Note
     */
    'confidence'?: number;
}
/**
 * A Problem Details object (RFC 9457).  Additional properties specific to the problem type may be present. 
 * @export
 * @interface Problem
 */
export interface Problem {
    /**
     * An absolute URI that identifies the problem type
     * @type {string}
     * @memberof Problem
     */
    'type'?: string;
    /**
     * An absolute URI that, when dereferenced, provides human-readable documentation for the problem type (e.g. using HTML).
     * @type {string}
     * @memberof Problem
     */
    'href'?: string;
    /**
     * A short summary of the problem type. Written in English and readable for engineers (usually not suited for non technical stakeholders and not localized).
     * @type {string}
     * @memberof Problem
     */
    'title'?: string;
    /**
     * The HTTP status code generated by the origin server for this occurrence of the problem.
     * @type {number}
     * @memberof Problem
     */
    'status'?: number;
    /**
     * A human-readable explanation specific to this occurrence of the problem
     * @type {string}
     * @memberof Problem
     */
    'detail'?: string;
    /**
     * An absolute URI that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     * @type {string}
     * @memberof Problem
     */
    'instance'?: string;
}
/**
 * 
 * @export
 * @interface Quote
 */
export interface Quote {
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'exchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'mic_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'datetime'?: string;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    'timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'open'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'high'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'low'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'close'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'volume'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'previous_close'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'change'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'percent_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'average_volume'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'rolling_1d_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'rolling_7d_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'rolling_period_change'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Quote
     */
    'is_market_open'?: boolean;
    /**
     * 
     * @type {QuoteFiftyTwoWeek}
     * @memberof Quote
     */
    'fifty_two_week'?: QuoteFiftyTwoWeek;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'extended_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'extended_percent_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof Quote
     */
    'extended_price'?: string;
    /**
     * 
     * @type {number}
     * @memberof Quote
     */
    'extended_timestamp'?: number;
}
/**
 * 
 * @export
 * @interface QuoteFiftyTwoWeek
 */
export interface QuoteFiftyTwoWeek {
    /**
     * 
     * @type {string}
     * @memberof QuoteFiftyTwoWeek
     */
    'low'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteFiftyTwoWeek
     */
    'high'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteFiftyTwoWeek
     */
    'low_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteFiftyTwoWeek
     */
    'high_change'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteFiftyTwoWeek
     */
    'low_change_percent'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteFiftyTwoWeek
     */
    'high_change_percent'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuoteFiftyTwoWeek
     */
    'range'?: string;
}
/**
 * 
 * @export
 * @interface Stock
 */
export interface Stock {
    /**
     * 
     * @type {string}
     * @memberof Stock
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Stock
     */
    'symbol'?: string;
    /**
     * 
     * @type {Array<Note>}
     * @memberof Stock
     */
    'notes'?: Array<Note>;
}
/**
 * 
 * @export
 * @interface StockMetadata
 */
export interface StockMetadata {
    /**
     * 
     * @type {string}
     * @memberof StockMetadata
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockMetadata
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockMetadata
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockMetadata
     */
    'exchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockMetadata
     */
    'mic_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockMetadata
     */
    'exchange_timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockMetadata
     */
    'period'?: string;
}
/**
 * 
 * @export
 * @interface TimeSeriesPoint
 */
export interface TimeSeriesPoint {
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesPoint
     */
    'datetime': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesPoint
     */
    'open': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesPoint
     */
    'high': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesPoint
     */
    'low': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesPoint
     */
    'close': string;
    /**
     * 
     * @type {string}
     * @memberof TimeSeriesPoint
     */
    'volume': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add analysis note to a watched stock
         * @param {string} symbol 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNote: async (symbol: string, note: Note, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('addNote', 'symbol', symbol)
            // verify required parameter 'note' is not null or undefined
            assertParamExists('addNote', 'note', note)
            const localVarPath = `/stocks/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new stock
         * @param {AddStockRequest} addStockRequest Stock object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStock: async (addStockRequest: AddStockRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addStockRequest' is not null or undefined
            assertParamExists('addStock', 'addStockRequest', addStockRequest)
            const localVarPath = `/stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addStockRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a note from a watched stock
         * @param {string} symbol Stock ticker symbol
         * @param {string} noteId Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote: async (symbol: string, noteId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('deleteNote', 'symbol', symbol)
            // verify required parameter 'noteId' is not null or undefined
            assertParamExists('deleteNote', 'noteId', noteId)
            const localVarPath = `/stocks/{symbol}/{noteId}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)))
                .replace(`{${"noteId"}}`, encodeURIComponent(String(noteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the income statement for a given financial instrument.
         * @summary Get Income Statement
         * @param {string} symbol 
         * @param {string} [figi] 
         * @param {string} [exchange] 
         * @param {string} [micCode] 
         * @param {string} [country] 
         * @param {GetIncomeStatementPeriodEnum} [period] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeStatement: async (symbol: string, figi?: string, exchange?: string, micCode?: string, country?: string, period?: GetIncomeStatementPeriodEnum, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getIncomeStatement', 'symbol', symbol)
            const localVarPath = `/market-data/income-statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (figi !== undefined) {
                localVarQueryParameter['figi'] = figi;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }

            if (micCode !== undefined) {
                localVarQueryParameter['mic_code'] = micCode;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get stock quote
         * @param {string} symbol 
         * @param {string} apiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockQuote: async (symbol: string, apiKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getStockQuote', 'symbol', symbol)
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getStockQuote', 'apiKey', apiKey)
            const localVarPath = `/market-data/quote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve time series data for a financial instrument
         * @param {string} symbol Symbol ticker of the instrument (e.g., AAPL, EUR/USD, ETH/BTC)
         * @param {string} apiKey 
         * @param {GetTimeSeriesDataIntervalEnum} interval Interval between two consecutive points in time series
         * @param {string} [figi] Filter by financial instrument global identifier (FIGI)
         * @param {string} [exchange] Exchange where instrument is traded
         * @param {string} [micCode] Market Identifier Code (MIC) under ISO 10383 standard
         * @param {string} [country] Country where instrument is traded
         * @param {GetTimeSeriesDataTypeEnum} [type] The asset class to which the instrument belongs
         * @param {number} [outputsize] Number of data points to retrieve (default 30 when no date parameters are set, otherwise set to maximum)
         * @param {GetTimeSeriesDataFormatEnum} [format] Format of the response (default JSON)
         * @param {string} [delimiter] Specify the delimiter used when downloading the CSV file (default semicolon ;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeSeriesData: async (symbol: string, apiKey: string, interval: GetTimeSeriesDataIntervalEnum, figi?: string, exchange?: string, micCode?: string, country?: string, type?: GetTimeSeriesDataTypeEnum, outputsize?: number, format?: GetTimeSeriesDataFormatEnum, delimiter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTimeSeriesData', 'symbol', symbol)
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getTimeSeriesData', 'apiKey', apiKey)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getTimeSeriesData', 'interval', interval)
            const localVarPath = `/market-data/time-series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            if (figi !== undefined) {
                localVarQueryParameter['figi'] = figi;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (exchange !== undefined) {
                localVarQueryParameter['exchange'] = exchange;
            }

            if (micCode !== undefined) {
                localVarQueryParameter['mic_code'] = micCode;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (outputsize !== undefined) {
                localVarQueryParameter['outputsize'] = outputsize;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['delimiter'] = delimiter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve list of watched stocks
         * @summary Get a list of stocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchedStocks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a watched stock from watchlist
         * @param {string} symbol Stock ticker symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeStock: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('removeStock', 'symbol', symbol)
            const localVarPath = `/stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add analysis note to a watched stock
         * @param {string} symbol 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNote(symbol: string, note: Note, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNote(symbol, note, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a new stock
         * @param {AddStockRequest} addStockRequest Stock object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addStock(addStockRequest: AddStockRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addStock(addStockRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.addStock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a note from a watched stock
         * @param {string} symbol Stock ticker symbol
         * @param {string} noteId Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNote(symbol: string, noteId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNote(symbol, noteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteNote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the income statement for a given financial instrument.
         * @summary Get Income Statement
         * @param {string} symbol 
         * @param {string} [figi] 
         * @param {string} [exchange] 
         * @param {string} [micCode] 
         * @param {string} [country] 
         * @param {GetIncomeStatementPeriodEnum} [period] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncomeStatement(symbol: string, figi?: string, exchange?: string, micCode?: string, country?: string, period?: GetIncomeStatementPeriodEnum, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIncomeStatement200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncomeStatement(symbol, figi, exchange, micCode, country, period, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIncomeStatement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get stock quote
         * @param {string} symbol 
         * @param {string} apiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStockQuote(symbol: string, apiKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStockQuote(symbol, apiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getStockQuote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve time series data for a financial instrument
         * @param {string} symbol Symbol ticker of the instrument (e.g., AAPL, EUR/USD, ETH/BTC)
         * @param {string} apiKey 
         * @param {GetTimeSeriesDataIntervalEnum} interval Interval between two consecutive points in time series
         * @param {string} [figi] Filter by financial instrument global identifier (FIGI)
         * @param {string} [exchange] Exchange where instrument is traded
         * @param {string} [micCode] Market Identifier Code (MIC) under ISO 10383 standard
         * @param {string} [country] Country where instrument is traded
         * @param {GetTimeSeriesDataTypeEnum} [type] The asset class to which the instrument belongs
         * @param {number} [outputsize] Number of data points to retrieve (default 30 when no date parameters are set, otherwise set to maximum)
         * @param {GetTimeSeriesDataFormatEnum} [format] Format of the response (default JSON)
         * @param {string} [delimiter] Specify the delimiter used when downloading the CSV file (default semicolon ;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeSeriesData(symbol: string, apiKey: string, interval: GetTimeSeriesDataIntervalEnum, figi?: string, exchange?: string, micCode?: string, country?: string, type?: GetTimeSeriesDataTypeEnum, outputsize?: number, format?: GetTimeSeriesDataFormatEnum, delimiter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTimeSeriesData200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeSeriesData(symbol, apiKey, interval, figi, exchange, micCode, country, type, outputsize, format, delimiter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getTimeSeriesData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve list of watched stocks
         * @summary Get a list of stocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatchedStocks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Stock>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchedStocks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getWatchedStocks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove a watched stock from watchlist
         * @param {string} symbol Stock ticker symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeStock(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeStock(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.removeStock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Add analysis note to a watched stock
         * @param {string} symbol 
         * @param {Note} note 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNote(symbol: string, note: Note, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addNote(symbol, note, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a new stock
         * @param {AddStockRequest} addStockRequest Stock object that needs to be added
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addStock(addStockRequest: AddStockRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addStock(addStockRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a note from a watched stock
         * @param {string} symbol Stock ticker symbol
         * @param {string} noteId Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNote(symbol: string, noteId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteNote(symbol, noteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the income statement for a given financial instrument.
         * @summary Get Income Statement
         * @param {string} symbol 
         * @param {string} [figi] 
         * @param {string} [exchange] 
         * @param {string} [micCode] 
         * @param {string} [country] 
         * @param {GetIncomeStatementPeriodEnum} [period] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncomeStatement(symbol: string, figi?: string, exchange?: string, micCode?: string, country?: string, period?: GetIncomeStatementPeriodEnum, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetIncomeStatement200Response> {
            return localVarFp.getIncomeStatement(symbol, figi, exchange, micCode, country, period, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get stock quote
         * @param {string} symbol 
         * @param {string} apiKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockQuote(symbol: string, apiKey: string, options?: RawAxiosRequestConfig): AxiosPromise<Quote> {
            return localVarFp.getStockQuote(symbol, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve time series data for a financial instrument
         * @param {string} symbol Symbol ticker of the instrument (e.g., AAPL, EUR/USD, ETH/BTC)
         * @param {string} apiKey 
         * @param {GetTimeSeriesDataIntervalEnum} interval Interval between two consecutive points in time series
         * @param {string} [figi] Filter by financial instrument global identifier (FIGI)
         * @param {string} [exchange] Exchange where instrument is traded
         * @param {string} [micCode] Market Identifier Code (MIC) under ISO 10383 standard
         * @param {string} [country] Country where instrument is traded
         * @param {GetTimeSeriesDataTypeEnum} [type] The asset class to which the instrument belongs
         * @param {number} [outputsize] Number of data points to retrieve (default 30 when no date parameters are set, otherwise set to maximum)
         * @param {GetTimeSeriesDataFormatEnum} [format] Format of the response (default JSON)
         * @param {string} [delimiter] Specify the delimiter used when downloading the CSV file (default semicolon ;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeSeriesData(symbol: string, apiKey: string, interval: GetTimeSeriesDataIntervalEnum, figi?: string, exchange?: string, micCode?: string, country?: string, type?: GetTimeSeriesDataTypeEnum, outputsize?: number, format?: GetTimeSeriesDataFormatEnum, delimiter?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetTimeSeriesData200Response> {
            return localVarFp.getTimeSeriesData(symbol, apiKey, interval, figi, exchange, micCode, country, type, outputsize, format, delimiter, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve list of watched stocks
         * @summary Get a list of stocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchedStocks(options?: RawAxiosRequestConfig): AxiosPromise<Array<Stock>> {
            return localVarFp.getWatchedStocks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a watched stock from watchlist
         * @param {string} symbol Stock ticker symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeStock(symbol: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeStock(symbol, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Add analysis note to a watched stock
     * @param {string} symbol 
     * @param {Note} note 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addNote(symbol: string, note: Note, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addNote(symbol, note, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a new stock
     * @param {AddStockRequest} addStockRequest Stock object that needs to be added
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addStock(addStockRequest: AddStockRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).addStock(addStockRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a note from a watched stock
     * @param {string} symbol Stock ticker symbol
     * @param {string} noteId Note ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteNote(symbol: string, noteId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteNote(symbol, noteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the income statement for a given financial instrument.
     * @summary Get Income Statement
     * @param {string} symbol 
     * @param {string} [figi] 
     * @param {string} [exchange] 
     * @param {string} [micCode] 
     * @param {string} [country] 
     * @param {GetIncomeStatementPeriodEnum} [period] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getIncomeStatement(symbol: string, figi?: string, exchange?: string, micCode?: string, country?: string, period?: GetIncomeStatementPeriodEnum, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIncomeStatement(symbol, figi, exchange, micCode, country, period, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get stock quote
     * @param {string} symbol 
     * @param {string} apiKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStockQuote(symbol: string, apiKey: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getStockQuote(symbol, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve time series data for a financial instrument
     * @param {string} symbol Symbol ticker of the instrument (e.g., AAPL, EUR/USD, ETH/BTC)
     * @param {string} apiKey 
     * @param {GetTimeSeriesDataIntervalEnum} interval Interval between two consecutive points in time series
     * @param {string} [figi] Filter by financial instrument global identifier (FIGI)
     * @param {string} [exchange] Exchange where instrument is traded
     * @param {string} [micCode] Market Identifier Code (MIC) under ISO 10383 standard
     * @param {string} [country] Country where instrument is traded
     * @param {GetTimeSeriesDataTypeEnum} [type] The asset class to which the instrument belongs
     * @param {number} [outputsize] Number of data points to retrieve (default 30 when no date parameters are set, otherwise set to maximum)
     * @param {GetTimeSeriesDataFormatEnum} [format] Format of the response (default JSON)
     * @param {string} [delimiter] Specify the delimiter used when downloading the CSV file (default semicolon ;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTimeSeriesData(symbol: string, apiKey: string, interval: GetTimeSeriesDataIntervalEnum, figi?: string, exchange?: string, micCode?: string, country?: string, type?: GetTimeSeriesDataTypeEnum, outputsize?: number, format?: GetTimeSeriesDataFormatEnum, delimiter?: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTimeSeriesData(symbol, apiKey, interval, figi, exchange, micCode, country, type, outputsize, format, delimiter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve list of watched stocks
     * @summary Get a list of stocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWatchedStocks(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWatchedStocks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a watched stock from watchlist
     * @param {string} symbol Stock ticker symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public removeStock(symbol: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).removeStock(symbol, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetIncomeStatementPeriodEnum = {
    Annual: 'annual',
    Quarterly: 'quarterly'
} as const;
export type GetIncomeStatementPeriodEnum = typeof GetIncomeStatementPeriodEnum[keyof typeof GetIncomeStatementPeriodEnum];
/**
 * @export
 */
export const GetTimeSeriesDataIntervalEnum = {
    _1min: '1min',
    _5min: '5min',
    _15min: '15min',
    _30min: '30min',
    _45min: '45min',
    _1h: '1h',
    _2h: '2h',
    _4h: '4h',
    _1day: '1day',
    _1week: '1week',
    _1month: '1month'
} as const;
export type GetTimeSeriesDataIntervalEnum = typeof GetTimeSeriesDataIntervalEnum[keyof typeof GetTimeSeriesDataIntervalEnum];
/**
 * @export
 */
export const GetTimeSeriesDataTypeEnum = {
    AmericanDepositaryReceipt: 'American Depositary Receipt',
    Bond: 'Bond',
    BondFund: 'Bond Fund',
    ClosedEndFund: 'Closed-end Fund',
    CommonStock: 'Common Stock',
    DepositaryReceipt: 'Depositary Receipt',
    DigitalCurrency: 'Digital Currency',
    Etf: 'ETF',
    ExchangeTradedNote: 'Exchange-Traded Note',
    GlobalDepositaryReceipt: 'Global Depositary Receipt',
    Index: 'Index',
    LimitedPartnership: 'Limited Partnership',
    MutualFund: 'Mutual Fund',
    PhysicalCurrency: 'Physical Currency',
    PreferredStock: 'Preferred Stock',
    Reit: 'REIT',
    Right: 'Right',
    StructuredProduct: 'Structured Product',
    Trust: 'Trust',
    Unit: 'Unit',
    Warrant: 'Warrant'
} as const;
export type GetTimeSeriesDataTypeEnum = typeof GetTimeSeriesDataTypeEnum[keyof typeof GetTimeSeriesDataTypeEnum];
/**
 * @export
 */
export const GetTimeSeriesDataFormatEnum = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;
export type GetTimeSeriesDataFormatEnum = typeof GetTimeSeriesDataFormatEnum[keyof typeof GetTimeSeriesDataFormatEnum];


